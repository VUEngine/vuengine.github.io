---
layout: documentation
parents: Documentation > Tutorial
title: Actors
---

# Actors

[Actors](/documentation/api/class-actor/) are the heart of the [VUEngine](https://github.com/VUEngine/VUEngine-Core). They are the objects that the player manipulates and interact with.  the data used to populate the levels of games developed with it.

[Actors](/documentation/api/class-actor/) are [Entities](/documentation/api/class-entity/) in [VUEngine](https://github.com/VUEngine/VUEngine-Core), and [Entitys](/documentation/api/class-entity/) support [compositionality](/documentation/user-guide/design-principles/#components/) through [Components](/documentation/api/class-component/) that can be attached to them to add functionality.

[Components](/documentation/api/class-component/) can be:

- Behaviors
- Colliders
- Mutators
- Physical bodies
- Sprites
- Wireframes

[Entities](/documentation/api/class-entity/) can have attached to them as many [Components](/documentation/api/class-component/) as memory allows, except for [Bodies](/documentation/api/class-body/), of which can only be one attached to each, and for [Mutators](/documentation/api/class-mutator/) since only one cat be active at any time.

## ActorSpec

[Actors](/documentation/api/class-actor/) and [Components](/documentation/api/class-component/) in [VUEngine](https://github.com/VUEngine/VUEngine-Core) receive a special struct in their constructors that hold the initialization values for the instance that is being create, they are like recipes. These structs are called **Spec**s, as a short for “specification”.

[ActorSpecs](/documentation/api/struct-actor-spec/) are the recipes for [Actors](/documentation/api/class-actor/). They define the data used to populate the levels of games developed with it.

For most usages, they are auto generated by [VUEngine Studio](https://www.vuengine.dev/)'s **ActorEditor** so, you can skip this section to the [next](/documentation/tutorial/pong-paddles/) if you don't want to know the details of how they structured and don't need yet to create classes that inherit from [Actor](/documentation/api/class-actor/). 

The [ActorSpec](/documentation/api/struct-actor-spec/) is declared as follows:

```cpp
typedef struct ActorSpec
{
    /// Class allocator
    AllocatorPointer allocator;

    /// Component specs
    ComponentSpec** componentSpecs;

    /// Children specs
    struct PositionedActor* childrenSpecs;

    /// Extra info
    void* extraInfo;

    // Size
    // If 0, it is computed from the visual components if any
    PixelSize pixelSize;

    // Actor's in-game type
    uint8 inGameType;

    /// Array of function animations
    const AnimationFunction** animationFunctions;

    /// Animation to play automatically
    char* initialAnimation;

} ActorSpec;
```

Lets examine the **LowPowerIndicatorActorSpec**, which is a derivation of the [ActorSpec](/documentation/api/struct-actor-spec/):

```cpp
LowPowerActorROMSpec LowPowerIndicatorActorSpec =
{
    // Animated actor
    {
        // Class allocator
        __TYPE(LowPowerActor),

        // Component specs
        (ComponentSpec**)LowPowerIndicatorActorComponentSpecs,

        // Children specs
        NULL,

        // Extra info
        NULL,

        // Size
        // If 0, it is computed from the visual components if any
        {0, 0, 0},

        // Actor's in-game type
        kTypeNone,

        // Pointer to animation functions array
        (const AnimationFunction**)LowPowerIndicatorAnimationSpecs,

        // Animation to play automatically
        "Hide",
    }
};
```

The following line tells the engine the class to instantiate, in this case, it is a `LowPowerActor`, which inherits from `Actor`:

```cpp 
__TYPE(LowPowerActor),
``` 

As you can see, the **LowPowerActorROMSpec**'s first attribute is [ActorSpec](/documentation/api/struct-actor-spec/). **Specs** are chained together to support inheritance and instantiantion of inheriting classes through them. The **LowPowerActorROMSpec**'s definition is:

```cpp
typedef struct LowPowerActorSpec
{
    ActorSpec actorSpec;

} LowPowerActorSpec;
```

In the `componentSpecs` field, the **LowPowerActorROMSpec** specifies that the engine must attach to the `LowPowerIndicator` instance a number of [Components](/documentation/api/class-component/) initialized with the [ComponentSpecs](/documentation/api/struct-component-spec/) listed in **LowPowerIndicatorActorComponentSpecs**:

```cpp
ComponentSpec* const LowPowerIndicatorActorComponentSpecs[] = 
{
    (ComponentSpec*)&LowPowerIndicatorSpriteSpec,
    NULL
};
```

It should be obvious by this point that it is **Specs** all the way through. The **LowPowerIndicatorSpriteSpec** specifies to create a [BgmapSprite](/documentation/api/class-bgmap-sprite/):

```cpp
BgmapSpriteROMSpec LowPowerIndicatorSpriteSpec =
{
    [...]

        // Spec for the texture to display
        (TextureSpec*)&LowPowerIndicatorTextureSpec,

    [...]
};
```
The **LowPowerIndicatorSpriteSpec**, in turn, uses the **LowPowerIndicatorTextureSpec** to initialize a [Texture](/documentation/api/class-texture/), and this is were we find the image's dimensions that we use to properly place the low power indicator at the bottom of the screen:

```cpp
TextureROMSpec LowPowerIndicatorTextureSpec =
{
    // Pointer to the char spec that the texture uses
    (CharSetSpec*)&LowPowerIndicatorCharsetSpec,

    // Pointer to the map array that defines how to use the tiles from the char set
    LowPowerIndicatorMap,

    // Horizontal size in tiles of the texture (max. 64)
    2,

    // Vertical size in tiles of the texture (max. 64)
    1,

    // Padding added to the size for affine/hbias transformations (cols, rows)
    {0, 0},

    // Number of frames that the texture supports
    1,

    // Palette index to use by the graphical data (0 - 3)
    0,

    // Flag to recyble the texture with a different map
    false,

    // Flag to vertically flip the image
    false,

    // Flag to horizontally flip the image
    false,
};
```

The horizontal and vertical sizes are in tile units, and each [tile](/documentation/user-guide/graphics/) is a 8x8 pixels square. So, we placed the indicator at coordiantes (-192 + 8, 112 - 4, 0) because the Virtual Boy's screen's resolution is 384x224 pixels, while the indicator's image's width is 2x8 pixels and its height is 1x8 pixels. Hence, we had to displace it 2x8/2 = 8 pixels horizontally and 1x8/2 - 4 pixels vertically.  

Finally, **LowPowerIndicatorTextureSpec** uses **LowPowerIndicatorCharsetSpec** to create and initialize a [CharSet](/documentation/api/class-char-set/), which holds the reference to the pixel data. For more details, check [here](/documentation/user-guide/graphics/) the graphics section in the [user guide](/documentation/user-guide/).

```cpp
CharSetROMSpec LowPowerIndicatorCharsetSpec =
{
    [...]

    // Tiles array
    LowPowerIndicatorTiles,

    [...]
};
```